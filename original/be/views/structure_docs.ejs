<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>專案結構文檔 - AIOT 數據平台</title>
    <style>
      body {
        font-family: 'Microsoft JhengHei', Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f8f9fa;
        line-height: 1.6;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        padding: 2rem;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }
      h1 {
        color: #2c3e50;
        border-bottom: 3px solid #007bff;
        padding-bottom: 10px;
        text-align: center;
      }
      h2 {
        color: #34495e;
        border-left: 4px solid #007bff;
        padding-left: 15px;
        margin-top: 30px;
      }
      h3 {
        color: #5d6d7e;
        margin-top: 25px;
      }
      .nav-btn {
        background-color: #6c757d;
        color: white;
        border: none;
        padding: 10px 20px;
        font-size: 14px;
        border-radius: 5px;
        cursor: pointer;
        text-decoration: none;
        display: inline-block;
        margin-bottom: 20px;
        transition: background-color 0.3s;
      }
      .nav-btn:hover {
        background-color: #5a6268;
      }
      .code-block {
        background-color: #2d3748;
        color: #e2e8f0;
        padding: 15px;
        border-radius: 5px;
        font-family: 'Consolas', 'Monaco', monospace;
        overflow-x: auto;
        margin: 15px 0;
      }
      .tree {
        font-family: 'Consolas', 'Monaco', monospace;
        background-color: #f8f9fa;
        padding: 15px;
        border: 1px solid #dee2e6;
        border-radius: 5px;
        margin: 15px 0;
      }
      .tech-stack {
        margin: 20px 0;
      }
      .tech-item {
        margin: 15px 0;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      }
      .tech-item details {
        margin: 0;
      }
      .tech-item summary {
        background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
        color: white;
        padding: 15px 20px;
        cursor: pointer;
        font-size: 18px;
        font-weight: 600;
        list-style: none;
        user-select: none;
        transition: all 0.3s ease;
        position: relative;
      }
      .tech-item summary:hover {
        background: linear-gradient(135deg, #0056b3 0%, #004085 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      }
      .tech-item summary::-webkit-details-marker {
        display: none;
      }
      .tech-item summary::after {
        content: '+';
        position: absolute;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 24px;
        font-weight: bold;
        transition: transform 0.3s ease;
      }
      .tech-item details[open] summary::after {
        transform: translateY(-50%) rotate(45deg);
      }
      .tech-content {
        padding: 20px;
        background: #f8f9fa;
        border-top: 1px solid #dee2e6;
      }
      .why-how-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 15px;
      }
      .why-section, .how-section {
        background: white;
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid #28a745;
      }
      .how-section {
        border-left-color: #ffc107;
      }
      .section-title {
        font-size: 16px;
        font-weight: 600;
        color: #2c3e50;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .why-icon::before { content: "💡"; }
      .how-icon::before { content: "🔧"; }
      @media (max-width: 768px) {
        .why-how-grid {
          grid-template-columns: 1fr;
        }
      }
      ul {
        padding-left: 25px;
      }
      li {
        margin-bottom: 5px;
      }
    </style>
</head>
<body>
    <div class="container">
      <a class="nav-btn" href="/">← 返回首頁</a>
      
      <h1>AIOT 專案結構文檔</h1>
      
      <h2>專案概述</h2>
      <p>這是一個基於 Node.js + TypeScript 的 IOT 數據平台，採用現代化的微服務架構設計，支持無人機數據收集、處理和可視化。</p>
      
      <h2>技術棧</h2>
      <div class="tech-stack">
        
        <div class="tech-item">
          <details>
            <summary>Node.js + TypeScript</summary>
            <div class="tech-content">
              <p>現代化的 JavaScript 運行環境搭配強型別系統</p>
              <div class="why-how-grid">
                <div class="why-section">
                  <div class="section-title why-icon">為什麼選用</div>
                  <ul>
                    <li><strong>類型安全</strong>：TypeScript 提供編譯時錯誤檢查，減少運行時錯誤</li>
                    <li><strong>開發效率</strong>：強大的 IDE 支援，自動補全和重構功能</li>
                    <li><strong>生態豐富</strong>：npm 生態系統擁有龐大的套件庫</li>
                    <li><strong>高性能</strong>：V8 引擎的非阻塞 I/O 模型適合高並發應用</li>
                  </ul>
                </div>
                <div class="how-section">
                  <div class="section-title how-icon">如何使用</div>
                  <ul>
                    <li><strong>專案配置</strong>：使用 tsconfig.json 配置 TypeScript 編譯選項</li>
                    <li><strong>類型定義</strong>：定義 interface 和 type 確保代碼一致性</li>
                    <li><strong>模組系統</strong>：使用 ES6 模組進行代碼組織</li>
                    <li><strong>建構流程</strong>：透過 tsc 編譯器將 TypeScript 轉換為 JavaScript</li>
                  </ul>
                </div>
              </div>
            </div>
          </details>
        </div>

        <div class="tech-item">
          <details>
            <summary>Express.js 框架</summary>
            <div class="tech-content">
              <p>快速、靈活的 Node.js Web 應用程式框架</p>
              <div class="why-how-grid">
                <div class="why-section">
                  <div class="section-title why-icon">為什麼選用</div>
                  <ul>
                    <li><strong>簡潔明瞭</strong>：最小化的框架，易於理解和擴展</li>
                    <li><strong>中間件生態</strong>：豐富的中間件系統，可組合各種功能</li>
                    <li><strong>路由靈活</strong>：支援 RESTful API 設計模式</li>
                    <li><strong>社群成熟</strong>：穩定可靠，廣泛使用於企業級應用</li>
                  </ul>
                </div>
                <div class="how-section">
                  <div class="section-title how-icon">如何使用</div>
                  <ul>
                    <li><strong>應用程式結構</strong>：App 類別封裝 Express 實例和配置</li>
                    <li><strong>路由設計</strong>：按功能模組分離路由檔案</li>
                    <li><strong>中間件配置</strong>：CORS、日誌、認證等中間件統一管理</li>
                    <li><strong>錯誤處理</strong>：全域錯誤處理機制確保穩定性</li>
                  </ul>
                </div>
              </div>
            </div>
          </details>
        </div>

        <div class="tech-item">
          <details>
            <summary>InversifyJS 依賴注入</summary>
            <div class="tech-content">
              <p>強大的 IoC 容器，實現控制反轉和依賴注入</p>
              <div class="why-how-grid">
                <div class="why-section">
                  <div class="section-title why-icon">為什麼選用</div>
                  <ul>
                    <li><strong>解耦架構</strong>：降低模組間的耦合度，提高可維護性</li>
                    <li><strong>測試友好</strong>：易於進行單元測試和模擬依賴</li>
                    <li><strong>配置靈活</strong>：支援多種綁定模式和生命週期管理</li>
                    <li><strong>TypeScript 支援</strong>：完整的類型檢查和裝飾器支援</li>
                  </ul>
                </div>
                <div class="how-section">
                  <div class="section-title how-icon">如何使用</div>
                  <ul>
                    <li><strong>容器配置</strong>：在 container.ts 中定義服務綁定</li>
                    <li><strong>介面定義</strong>：使用 TypeScript 介面定義服務契約</li>
                    <li><strong>裝飾器注入</strong>：@injectable 和 @inject 裝飾器管理依賴</li>
                    <li><strong>生命週期</strong>：singleton 和 transient 模式控制實例創建</li>
                  </ul>
                </div>
              </div>
            </div>
          </details>
        </div>

        <div class="tech-item">
          <details>
            <summary>CQRS 架構模式</summary>
            <div class="tech-content">
              <p>命令查詢責任分離，優化讀寫操作的架構模式</p>
              <div class="why-how-grid">
                <div class="why-section">
                  <div class="section-title why-icon">為什麼選用</div>
                  <ul>
                    <li><strong>性能優化</strong>：讀寫分離，針對不同操作進行最佳化</li>
                    <li><strong>擴展性強</strong>：可獨立擴展讀取和寫入服務</li>
                    <li><strong>清晰職責</strong>：明確區分業務邏輯和資料查詢</li>
                    <li><strong>複雜度管理</strong>：分層架構降低系統複雜度</li>
                  </ul>
                </div>
                <div class="how-section">
                  <div class="section-title how-icon">如何使用</div>
                  <ul>
                    <li><strong>Commands 層</strong>：處理資料變更操作（Create, Update, Delete）</li>
                    <li><strong>Queries 層</strong>：處理資料查詢操作（Read）</li>
                    <li><strong>Service 分離</strong>：CommandsSvc 和 QueriesSvc 分別處理不同操作</li>
                    <li><strong>Repository 模式</strong>：命令和查詢倉庫獨立實現</li>
                  </ul>
                </div>
              </div>
            </div>
          </details>
        </div>

        <div class="tech-item">
          <details>
            <summary>MySQL + Sequelize ORM</summary>
            <div class="tech-content">
              <p>關聯式資料庫搭配強大的 ORM 框架</p>
              <div class="why-how-grid">
                <div class="why-section">
                  <div class="section-title why-icon">為什麼選用</div>
                  <ul>
                    <li><strong>ACID 特性</strong>：確保資料完整性和交易安全</li>
                    <li><strong>成熟穩定</strong>：經過長期驗證的企業級資料庫</li>
                    <li><strong>ORM 抽象</strong>：Sequelize 提供高階資料庫操作介面</li>
                    <li><strong>效能優異</strong>：索引優化和查詢計劃提升效能</li>
                  </ul>
                </div>
                <div class="how-section">
                  <div class="section-title how-icon">如何使用</div>
                  <ul>
                    <li><strong>模型定義</strong>：使用 Sequelize 定義資料表結構和關聯</li>
                    <li><strong>連線池管理</strong>：配置連線池提升資料庫存取效能</li>
                    <li><strong>交易處理</strong>：使用事務確保資料一致性</li>
                    <li><strong>歸檔機制</strong>：歷史資料歸檔降低主表查詢壓力</li>
                  </ul>
                </div>
              </div>
            </div>
          </details>
        </div>

        <div class="tech-item">
          <details>
            <summary>WebSocket + Socket.IO</summary>
            <div class="tech-content">
              <p>即時雙向通訊協議，支援實時資料更新</p>
              <div class="why-how-grid">
                <div class="why-section">
                  <div class="section-title why-icon">為什麼選用</div>
                  <ul>
                    <li><strong>即時通訊</strong>：支援低延遲的即時資料推送</li>
                    <li><strong>雙向傳輸</strong>：客戶端和服務端可以主動發送訊息</li>
                    <li><strong>自動重連</strong>：Socket.IO 提供斷線重連機制</li>
                    <li><strong>跨平台支援</strong>：支援多種客戶端平台和瀏覽器</li>
                  </ul>
                </div>
                <div class="how-section">
                  <div class="section-title how-icon">如何使用</div>
                  <ul>
                    <li><strong>命名空間</strong>：按功能劃分不同的 WebSocket 命名空間</li>
                    <li><strong>事件驅動</strong>：基於事件的訊息處理架構</li>
                    <li><strong>認證中間件</strong>：JWT 認證確保連線安全性</li>
                    <li><strong>廣播機制</strong>：支援一對多和多對多的訊息廣播</li>
                  </ul>
                </div>
              </div>
            </div>
          </details>
        </div>

        <div class="tech-item">
          <details>
            <summary>React 18 + TypeScript</summary>
            <div class="tech-content">
              <p>現代化前端框架搭配類型安全的開發體驗</p>
              <div class="why-how-grid">
                <div class="why-section">
                  <div class="section-title why-icon">為什麼選用</div>
                  <ul>
                    <li><strong>元件化開發</strong>：可重複使用的 UI 元件提高開發效率</li>
                    <li><strong>虛擬 DOM</strong>：優化渲染效能，提供流暢用戶體驗</li>
                    <li><strong>豐富生態</strong>：龐大的社群和套件生態系統</li>
                    <li><strong>並發功能</strong>：React 18 的並發特性提升應用響應性</li>
                  </ul>
                </div>
                <div class="how-section">
                  <div class="section-title how-icon">如何使用</div>
                  <ul>
                    <li><strong>元件架構</strong>：函數式元件搭配 Hooks 進行狀態管理</li>
                    <li><strong>路由管理</strong>：React Router 處理單頁應用導航</li>
                    <li><strong>狀態管理</strong>：Context API 和自訂 Hooks 管理全域狀態</li>
                    <li><strong>API 整合</strong>：Axios 處理 HTTP 請求和錯誤處理</li>
                  </ul>
                </div>
              </div>
            </div>
          </details>
        </div>

        <div class="tech-item">
          <details>
            <summary>Docker 容器化</summary>
            <div class="tech-content">
              <p>輕量級容器技術，實現一致的部署環境</p>
              <div class="why-how-grid">
                <div class="why-section">
                  <div class="section-title why-icon">為什麼選用</div>
                  <ul>
                    <li><strong>環境一致性</strong>：開發、測試、生產環境完全一致</li>
                    <li><strong>快速部署</strong>：容器化應用可快速啟動和擴展</li>
                    <li><strong>資源隔離</strong>：容器間資源隔離，避免依賴衝突</li>
                    <li><strong>微服務支援</strong>：適合微服務架構的部署模式</li>
                  </ul>
                </div>
                <div class="how-section">
                  <div class="section-title how-icon">如何使用</div>
                  <ul>
                    <li><strong>Dockerfile</strong>：定義應用程式的容器建構過程</li>
                    <li><strong>docker-compose</strong>：編排多個服務容器的運行</li>
                    <li><strong>熱重載</strong>：開發環境支援代碼變更自動重新載入</li>
                    <li><strong>環境變數</strong>：透過環境變數管理不同環境配置</li>
                  </ul>
                </div>
              </div>
            </div>
          </details>
        </div>

      </div>
      
      <h2>專案結構</h2>
      <div class="tree">
AIOT/
├── be/                     # 後端服務
│   ├── src/
│   │   ├── app.ts          # 應用程式入口
│   │   ├── configs/        # 配置檔案
│   │   ├── container/      # IoC 容器設定
│   │   ├── controllers/    # 控制器層 (CQRS)
│   │   │   ├── commands/   # 命令處理器
│   │   │   └── queries/    # 查詢處理器
│   │   ├── middlewares/    # 中間件
│   │   ├── repo/           # 資料訪問層
│   │   │   ├── commands/   # 寫入操作
│   │   │   └── queries/    # 讀取操作
│   │   ├── routes/         # 路由定義
│   │   ├── services/       # 業務邏輯層
│   │   ├── types/          # 類型定義
│   │   ├── utils/          # 工具函數
│   │   └── websocket/      # WebSocket 處理
│   ├── views/              # EJS 模板
│   ├── logs/               # 日誌檔案
│   └── package.json
├── fe/                     # 前端應用
│   ├── src/
│   │   ├── components/     # React 組件
│   │   ├── hooks/          # 自訂 Hooks
│   │   ├── pages/          # 頁面組件
│   │   ├── services/       # API 服務
│   │   ├── types/          # 類型定義
│   │   └── utils/          # 工具函數
│   └── package.json
└── docker-compose.yml      # Docker 編排
      </div>
      
      <h2>架構設計原則</h2>
      
      <h3>CQRS (Command Query Responsibility Segregation)</h3>
      <p>採用 CQRS 模式分離讀寫操作：</p>
      <ul>
        <li>Commands：處理資料變更操作（Create, Update, Delete）</li>
        <li>Queries：處理資料查詢操作（Read）</li>
        <li>提高系統可維護性和擴展性</li>
      </ul>
      
      <h3>依賴注入 (InversifyJS)</h3>
      <p>使用 IoC 容器管理依賴關係：</p>
      <ul>
        <li>降低組件間耦合度</li>
        <li>提高程式碼可測試性</li>
        <li>支持介面導向程式設計</li>
      </ul>
      
      <h3>分層架構</h3>
      <p>清晰的分層設計：</p>
      <ul>
        <li>Controller 層：處理 HTTP 請求和回應</li>
        <li>Service 層：實現業務邏輯</li>
        <li>Repository 層：資料訪問抽象</li>
        <li>每層職責單一，易於維護</li>
      </ul>
      
      <h2>核心功能模組</h2>
      
      <h3>認證與權限管理 (RBAC)</h3>
      <ul>
        <li>JWT Token 認證機制</li>
        <li>Role-Based Access Control</li>
        <li>使用者、角色、權限三層管理</li>
        <li>Session 管理</li>
      </ul>
      
      <h3>無人機數據管理</h3>
      <ul>
        <li>無人機狀態監控</li>
        <li>位置數據追蹤</li>
        <li>命令隊列管理</li>
        <li>實時狀態更新 (WebSocket)</li>
        <li>歷史數據歸檔</li>
      </ul>
      
      <h3>即時通信系統</h3>
      <ul>
        <li>WebSocket 連接管理</li>
        <li>事件驅動架構</li>
        <li>多用戶廣播機制</li>
        <li>連接狀態監控</li>
      </ul>
      
      <h2>開發規範</h2>
      
      <h3>程式碼風格</h3>
      <ul>
        <li>使用 TypeScript 嚴格模式</li>
        <li>ESLint + Prettier 程式碼格式化</li>
        <li>JSDoc 註釋規範</li>
        <li>統一的錯誤處理機制</li>
      </ul>
      
      <h3>資料庫設計</h3>
      <ul>
        <li>標準化命名慣例</li>
        <li>外鍵約束完整性</li>
        <li>索引優化查詢性能</li>
        <li>軟刪除機制</li>
      </ul>
      
      <h3>API 設計</h3>
      <ul>
        <li>RESTful API 規範</li>
        <li>統一回應格式 (ControllerResult)</li>
        <li>HTTP 狀態碼標準化</li>
        <li>API 版本管理</li>
      </ul>
      
      <h2>部署與運維</h2>
      
      <h3>容器化部署</h3>
      <ul>
        <li>Docker 多階段建構</li>
        <li>docker-compose 編排</li>
        <li>環境變數配置管理</li>
        <li>日誌收集與輪轉</li>
      </ul>
      
      <h3>開發環境</h3>
      <ul>
        <li>Hot-reload 開發體驗</li>
        <li>自動化測試流程</li>
        <li>建構與部署腳本</li>
        <li>健康檢查機制</li>
      </ul>
      
      <h2>擴展計劃</h2>
      
      <h3>性能優化</h3>
      <ul>
        <li>資料庫查詢優化</li>
        <li>緩存機制實現</li>
        <li>負載均衡配置</li>
        <li>監控與告警系統</li>
      </ul>
      
      <h3>功能擴展</h3>
      <ul>
        <li>多租戶支持</li>
        <li>資料分析儀表板</li>
        <li>外部系統整合</li>
        <li>移動端應用支持</li>
      </ul>
      
      <p>
        <strong>更新時間：2025-08-07</strong><br>
        如有問題或建議，請聯繫開發團隊。
      </p>
    </div>
</body>
</html>